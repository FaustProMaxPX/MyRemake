# 计算机组成原理



## Number Rep

> 原码

首位作为符号位，其余各位表示数字



> 反码

当数字为负时的二进制表示是其整数对应原码各位取反。

但在进行运算时需要对其符号位作特殊处理。溢出位必须进行回卷才能得到整确结果。

同时在运算时也会得到冗余的-0



> 补码

各位取反末尾+1，其中最高的符号位可以将其当作负数直接参与计算，例如101 = -3 = (-1)*2^2 + 0 * 2 + 1*1。

让符号位直接参与运算可以使程序一致性更强。



## C的内存布局

![image-20220402192533268](C:\Users\ABD\AppData\Roaming\Typora\typora-user-images\image-20220402192533268.png)



Stack:存储临时变量，向下增长

Heap:存储动态分配的空间，向上增长

Static Data: 全局变量，静态变量，大小不会改变

tip:OS会阻止堆栈之间的访问，来避免在数据量过大时破坏原有的数据。





## RISC-V

risc-v拥有32个寄存器，每个寄存器长度为32位

> 寄存器与内存

当变量多于寄存器时，寄存器中存放使用最频繁的变量，其余存放到内存中去。



> risc-v 语法

op dst scr1 src2

`#`是注释

op 后可能会跟w，w表示一次处理寄存器中32位数据，而非整个寄存器中的数据，一般在处理数据长度大于32位的情况下出现。



> 立即数

数字常量被成为立即数

语法：opi  dst, scr, imm

原本第二个寄存器的位置被替换成立即数，操作符最后加上i

tip：立即数最高可达12位的长度， 用符号扩展的补码表示。



> Data Transfer

语法：memop reg, off(bAddr) => Access memory at bAddr + off

bAddr : 带有内存指针的寄存器

off : 代表偏移量的立即数

 

大端存放：最高有效字节存储在地址最低处。

小端存放：最低有效字节存储在地址最低处。



lb, sb 均对最低有效位进行操作

lh, sh 对半字操作

lu, su 无符号

区别：

- sb:高24位被忽略，只将低8位存储

- lb:高24位用符号位扩展。

  其余同理。

![image-20220404151504017](C:\Users\ABD\AppData\Roaming\Typora\typora-user-images\image-20220404151504017.png)

![image-20220404151603887](C:\Users\ABD\AppData\Roaming\Typora\typora-user-images\image-20220404151603887.png)



> 转移指令

beq reg1, reg2, label

- if value in reg1 = value in reg2 , jump to label
- else go to next instruction

bne reg1, reg2, label

blt (less than)

bgr (greater than)



j label

- unconditional jump



> 移位指令

sll(shift left logical expand)

sra(shift right algorithm expand) 

risc-v只用第二个操作数的最低5位进行移位操作。



> 乘除

mul dst, scr1, src2	提取结果的低32位

mulh dst. src1, scr2	提取结果的高32位



div dst, src1, src2

rem dst, src1, src2 取余数



> 比较

slt (set less than) dst, reg1, reg2

- if value in reg1 less than reg2, dst=1, else 0



> Environment call

ecall是一个应用程序于操作系统交互的方法

该指令不需要任何参数，他会将寄存器a0(不同的OS会有所区别)的值传递给操作系统，来指明要进行什么操作。



> 伪指令

li dst, imm

load 32-bit immediate into dst



la dst, label

load address of specificed label into dst



nop (do nothing)



> 寄存器

a0-a7:用于传递参数的寄存器

a0-a1：存储返回值的寄存器。

sp：栈帧，存储当前栈底，该寄存器不允许被修改

s0-s11(save register)：此类寄存器也不准备函数修改

如果函数需要使用保留寄存器或栈帧寄存器，他需要首先将寄存器中的内容维护起来，然后才可以使用这些寄存器。

而对于临时寄存器，参数寄存器，返回地址寄存器，调用者会自行保存。



> function

流程：

1. 将参数放到函数可以访问的地方
2. 移交控制权
3. 函数申请空间
4. 函数执行
5. 函数将返回值放到指定位置，然后释放空间
6. 返回控制权



跳转：

若单纯使用j进行跳转，则在每次跳转前需要在返回地址处创建一个标签。这样会显得代码臃肿。

使用jal可以将返回地址现存入到寄存器中，然后再移交控制权，函数根据寄存器中的值归还控制权。



jal(jump and link) dst label

在跳转前先将指令的地址存放到寄存器中。



jalr dst, reg, imm

先计算偏移后的地址，然后将该地址存储到dst，最后跳转



jr(jump register) src 

使用寄存器中的值进行跳转，src通常为ra

ra:存储返回地址的寄存器。







## 原理性概念（暂时没想好用什么标题）



### Program Counter

PC是一个特殊寄存器，他存储当前要执行的代码的地址。不能被访问。

分支语句和跳转语句就是通过修改PC的值来修改程序的执行流。



### Instruction Address

**指令被已数据的形式存储在内存中，并且他们也有自己的地址**

而标签会被转换成对应的指令地址。

