使用语言：Java

> 实例化对象的过程

首先根据构造函数传入的参数初始化对象中的属性，然后该对象的属性的首个bit所在的位置返回，作为该对象的地址被存入到对应的变量中。

所有地址长度位64位，null的地址为全0。



tips：所有的赋值操作都是将该变量存储的字节全部拷贝到另一个变量中。



## 链表

尽量避免特判可有效提高代码健壮性。

表头添加哨兵结点的思想：让链表在任何情况下的状态都遵循同一套操作逻辑。



在单链表中添加头部哑节点的原因是，在某些情况下无法访问链表中结点的next属性，因此我们通过添加哑节点来使next属性在任何时刻都可以被访问。

而对于双向链表，又出现了某些结点的prev属性不能被访问或是说不应该被访问。例如，按照原先单链表的设计，我们将需要在前插时对是否是头部哑节点进行特判。

此时有两种解决方法：

1. 在尾部也添加一个哑节点。
2. 将链表设计成循环链表。



## 顺序表

> resize

当顺序表需要进行resize操作时，将数组大小进行指数级更改，而非简单的加减。因为加减无法根据当前数据量的大小动态进行调整，导致在数据量过大时频繁地调用resize操作拖慢速度且占用大量空间。

若顺序表中数组存储的不是基本数据类型，则不推荐懒惰删除，因为被删除对象的引用仍然保存着，不会被gc回收，占用内存。



## 继承

继承会从父类继承所有的成员变量，静态变量，所有的方法和内部类。

但被private修饰的不可直接访问。

```java
// 调用父类方法
super.xxx();
```



tips:构造器都不会被继承，但Java会默认在子类构造器中首先调用基类默认*无参*构造器。



> 继承会破坏封装

Java根据动态数据类型调用方法，若子类中覆写了一个方法，其中调用了从基类继承来的方法，但此方法调用了基类中被覆写的方法，则此时不会调用父类中被覆写的方法，而是子类的方法，最终陷入无限循环。

封装被破坏的直接体现：模组中的方法不再以整体的形式被调用

